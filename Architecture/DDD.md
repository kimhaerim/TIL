# DDD Domain-Driven Design 도메인 중심 설계
> 도메인 : 소프트웨어가 해결하고자 하는 현실 세계의 문제 영역, 모델링하려는 비즈니스 개념들
- 소프트웨어 개발 방법론
- 도메인에 집중하여 도메인의 복잡성을 최소화하기 위해 소프트웨어를 설계하고 개발함
- 기술보다는 비즈니스 개념을 먼저 생각함
- 도메인 전문과와 개발자가 공통언어로 협업
- 시스템을 도메인 기준으로 나누고, 그 안의 로직을 객체지향적으로 모델링


## 핵심목표 : 느슨한 결합과 높은 응집성
### 1. Loosely Coupling (느슨한 결합) 
- 각 모듈이나 컴포넌트가 서로 독립적이고 최소한의 의존성을 가지도록 설계하는 것
### 2. High Cohesion (높은 응집성)
- 각 모듈이 자신의 역할에 집중하고 관련된 작업들만 처리하도록 설계하는 것

## DDD의 구성
```
┌──────────────────────┐
│  Presentation Layer  │  ← 사용자의 입력을 받음
│  (Controller, API)   │
└──────────────────────┘
            ↓
┌──────────────────────┐
│ Application Layer    │  ← 비즈니스 유스케이스를 실행
│ (Application Service)│
└──────────────────────┘
            ↓
┌──────────────────────┐
│   Domain Layer       │  ← 핵심 비즈니스 로직 (도메인 객체들)
│ (Entities, Value Objects, Services) │
└──────────────────────┘
            ↓
┌──────────────────────┐
│ Infrastructure Layer │  ← 외부 시스템과의 통합
│ (Repositories, DB)   │
└──────────────────────┘
```
- 위의 계층에서 아래 계층에는 접근이 가능하지만, 아래에서 위로는 불가능함
- 한 계층의 관심사와 관련된 어떤 것도 다른 계층에 배치되어서는 안됨

### 1. Presentation Layer (프레젠테이션 레이어)
- 역할 : 사용자와의 상호작용을 담당함
- 구성요소 : 웹 UI, API, 콘솔 애플리케이션 등의 인터페이스
- 책임 : 사용자의 입력을 받아 애플리케이션 서비스를 호출하고 결과를 사용자에게 보여줌
### 2. Application Layer (애플리케이션 레이어)
- 역할 : 유스케이스를 구현하며 도메인 객체를 조작함
- 구성 요소 : 애플리케이션 서비스, DTO 등
- 책임 : 프레젠테이션 레이어로부터 받은 요청을 처리하여 도메인 모델을 사용해 비즈니스 로직을 실행
### 3. Domain Layer (도메인 레이어)
- 역할 : 시스템의 핵심 비즈니스 로직을 포함하여, 애플리케이션의 핵심 도메인을 표현
- 구성 요소 : 엔티티, 값 객체, 도메인 서비스, 애그리거트 등
- 책임 : 실제 도메인 규칙과 로직을 정의하여 시스템이 처리해야 하는 복잡한 비즈니스 문제를 해결
### 4. Infrastructure Layer (인프라 레이어)
- 역할 : 시스템의 외부 리소스나 기술적인 부분을 처리
- 구성 요소 : 데이터베이스, 외부 API, 메시징 시스템, 파일 시스템 등 외부와의 상호작용을 처리
- 책임 : 도메인 모델을 저장하거나 외부 시스템과 통신

## Bounded Context
- 도메인 주도 설계에서 처음 소개된 개념
- 큰 시스템을 여러 개의 작은 컨텍스트로 나누어 각 컨텍스트 내에세 특정한 비즈니스 규칙과 데이터 모델이 적용되는 것
- 전체 도메인을 작은 단위로 분리하여 각 바운디드 컨텍스트를 식별하고 각 컨텍스트가 독립적으로 동작하도록 설계해야 함


> Bounded Context: 모델이 유효한 명확한 경계를 정의하는 것 <br>
> Context: 특정 비즈니스 상황/환경 <br>
> Boundary: 그 Context가 적용되는 범위를 명확히 나누는 것

### 쇼핑몰 서비스에서의 "User"
1. 쇼핑을 하는 구매자인 `User` 
2. 관리자 시스템에서 관리하는 `User` 
3. 고객센터 시스템에 글을 남기는 `User` <br>
-> 같은 `User`이지만 다른 맥락과 다른 역할을 가지고 있음 <br>

각 시스템마다 Bounded Context를 나누면
1. 쇼핑을 하는 구매자인 `User`  -> Buyer
2. 관리자 시스템에서 관리하는 `User`  -> Admin User
3. 고객센터 시스템에 글을 남기는 `User` -> Customer <br>
-> 구분해서 사용함으로서 시스템이 서로 헷갈리지 않고 모델 충돌 없이 개발할 수 있음

### 장점
1. 모델 간의 충돌을 방지함, 쉽게 이해할 수 있음
2. 각 컨텍스트가 독립적으로 동작해 개발자들은 컨텍스트 단위로 작업할 수 있음
2. 시스템을 작은 영역으로 나눠서 독립적으로 개발할 수 있음, 확장성을 높일 수 있음
3. 팀 간 의사소통을 간소화할 수 있음

