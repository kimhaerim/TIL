# NodeJS vs NestJS

## NodeJs

- Chrome V8 Javascript 엔진으로 빌드된 자바스크립트 런타임 환경

### 특징

1. 비동기 이벤트 : 이벤트 기반의 비동기 처리로 입출력 작업을 기다리는 동안 다른 작업을 수행할 수 있음
2. 싱글스레드 : 이벤트 루프와 백그라운드 작업을 통해 많은 요청을 처리함

### 장점

1. 가볍고 빠름 : 필요한 만큼만 구성하므로 초기 런타임 속도나 메모리 사용면에서 더 가벼움
2. 자유로운 구조 설계 : 원하는 아키텍처를 자유롭게 구성할 수 있음
3. 최소한의 패키지로 시작할 수 있음
4. 단순한 라우터 + 미들웨어 구조이기 때문에 러닝커브가 낮음
5. 원하는 방식으로 미들웨어, 에러 핸들링, 로깅 등을 구성할 수 있음
   -> 작은 규모의 프로젝트이거나 빠른 MVP개발이 필요할 때 사용하면 좋음

### middleware와 routing

- 미들웨어 : 요청과 응답 사이에 중간 작업을 처리하는 함수
  > ex) 로그 기록, 인증, 에러 처리 등
- 라우팅 : 요청 경로와 메서드(GET, POST 등)에 따라 실행할 핸들러를 연결하는 것

### 라이프 사이클

```
[1] 클라이언트 요청
   ↓
[2] 앱 수준 미들웨어 (app.use)
   ↓
[3] 라우터 미들웨어 (app.get, app.post 등)
   ↓
[4] 라우트 핸들러 실행
   ↓
[5] 응답 반환 (res.send 등)
   ↓
[6] 에러 미들웨어 (문제 발생 시)
```

[1] 클라이언트 요청<br>
[2] 앱 수준 미들웨어 : 모든 요청에 공통적으로 실행되는 미들웨어, 반드시 next()를 호출해야 다음 단계로 넘어감<br>
`app.use(authMiddleware);       // 로그인 인증 검사`<br>
[3] 라우터 미들웨어 : url과 http 메서드에 따라 실행될 라우트를 선택함<br>

```js
app.get("/users", userListHandler);
app.post("/users", createUserHandler);
```

[4] 라우트 핸들러 실행 : 핸들러 함수가 실행되어 작업을 처리함<br>

```js
function userListHandler(req, res) {
  const users = [{ id: 1, name: "홍길동" }];
  res.json(users); // → 응답 완료
}
```

[5] 응답 반환 : 핸들러에서 res.send, res.json, res.status().send() 등을 호출하면 클라이언트에 응답을 보냄, 응답이 끝나면 라이프사이클이 종료<br>
[6] 에러 미들웨어 : 중간에 에러가 발생하면 next(err)를 통해 에러 미들웨어로 이동, 인자가 반드시 (err, req, res, next) 4개여야 함<br>

```js
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send("서버 에러 발생!");
});
```

### Node.js + TypeScript를 사용하는 경우 장점

- NestJS의 강제된 구조 없이도 TS의 장점을 누릴 수 있음
- 타입 안전성, 자동완성, 리팩토링 편의성
- 구현 방식이 자유롭고 유연함

**NodeJS(express)를 사용하면 디렉터리 구조(아키텍처)를 항상 고민해서 설계해야 함, 그래서 나온게 NestJS**

## NestJS

-> 서버 개발 시의 아키텍처를 누구든 비슷하게 설계할도록 아키텍처 문제를 해결하는데 중점

### 장점

1. 아키텍처가 체계적이라 대규모 서비스에서 유리함
2. DI가 내장되어 있음
   -> 모듈 내에서의 코드의 응집도는 높여서 모듈의 재사용을 꾀하고 모듈 간의 결합도를 낮춰서 코드 재사용을 용이하게 함
3. 데코레이터 기반으로 개발자 속도가 좋음
4. 테스트하기 좋은 구조
   -> 마이크로서비스, GraphQL, WebSocket 같은 기술 스택 통합이 잘되어 있음
